---
name: git-commit
description: 変更内容を分析し、Conventional Commits形式で対話的にコミットする。関心事が異なる変更は自動で分割提案する。「コミットして」「変更をコミットしたい」「git commit」などで発動。
---

# 対話的コミット

変更内容を分析し、関心事ごとにコミットを分割、Conventional Commits 形式のメッセージを提案して対話的にコミットする。

## 前提

- **Conventional Commits の慣例に従い、迷いを減らす**
  - 判断に迷った場合は慣例を優先する
  - 独自ルールは慣例で判断できない場合の補足に留め、最小限にする
- コミットメッセージは **日本語**
- 絵文字プレフィックスは使わない

## コミットメッセージ形式

```
<type>[optional scope]: <概要（日本語）>

[optional body（日本語）]

[optional footer(s)]
```

### type 一覧

| type     | 用途                 |
|----------|--------------------|
| feat     | 新機能の追加・既存機能の拡張     |
| fix      | バグ修正               |
| refactor | リファクタリング（振る舞い変更なし） |
| docs     | ドキュメントのみの変更        |
| style    | フォーマット修正（振る舞い変更なし） |
| chore    | ビルド・ツール・依存関係の変更    |
| test     | テストの追加・修正          |
| perf     | パフォーマンス改善          |
| ci       | CI設定の変更            |

### type 選定の判断基準

**feat を使うのは「ソースコードの機能の新設・拡張」に限る。** ドキュメントのみの変更や振る舞いを変えない整理は別の type を使う。

判断フローチャート:

1. **ドキュメント（.md等）やコメントだけの変更？** → `docs`
2. **ソースコードの機能を新設・拡張した？** → `feat`
3. **バグや不具合を直した？** → `fix`
4. **既存の振る舞いを変えずに構造を整理した？** → `refactor`
5. **フォーマット・空白・セミコロン等のみ？** → `style`
6. **テストの追加・修正のみ？** → `test`
7. **パフォーマンス改善？** → `perf`
8. **CI設定の変更？** → `ci`
9. **ビルド・ツール・依存関係の変更？** → `chore`

迷いやすいケースの判定例:

| 変更内容                  | type          | 理由                          |
|-----------------------|---------------|-----------------------------|
| 新しいAPIエンドポイントを追加      | feat          | ソースコードに新機能を新設               |
| 既存画面にフィルター機能を追加       | feat          | 既存機能への機能拡張                  |
| 関数の内部ロジックを整理（振る舞い同じ）  | refactor      | 振る舞いを変えない構造改善               |
| バリデーションの抜けを修正         | fix           | 不具合の修正                      |
| 既存スキルのワークフローを改善       | docs          | AIへの指示書でありコード実行に直接影響しない     |
| 新しいスキル（SKILL.md）を作成   | docs          | コード実行に直接影響しないドキュメントの新設      |
| package.jsonに新パッケージ追加 | feat or chore | 機能実装に伴うなら feat、ツール系なら chore |

### scope

変更が**単一のディレクトリ（モジュール）に閉じる場合**、そのディレクトリ名をscopeとして付与する。

- モノレポの場合: `apps/` や `packages/` 直下のディレクトリ名（例: `api`, `web`, `shared`）
- 変更が複数ディレクトリにまたがる場合: scopeを省略する
- 判断に迷う場合: 省略する（誤ったscopeより省略の方が安全）

### footer

以下を付与する:

- **Co-Authored-By**: 使用中のAIエージェントに応じた値を設定する
  - 例: `Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>`

## ワークフロー

各ステップの開始時に `### ステップN/5: タイトル` のヘッダーを表示し、全体の進行状況をユーザーにわかりやすく伝える。

### ステップ1/5: 変更内容の確認

```bash
git status
git diff
git diff --staged
```

- **変更がない場合**: 「コミットする変更がありません」と表示して終了
- staged / unstaged 両方を対象とする

### ステップ2/5: 変更内容の分析

変更されたファイルと diff の内容を分析し、**関心事ごとにグループ化**する。

分析の観点:

- ファイルの種類・パス（src/, docs/, tests/ など）
- 変更の性質（新規追加、修正、リファクタ、ドキュメント更新）
- 論理的なまとまり（同じ機能に関する変更はまとめる）

分析結果をテーブル形式で表示する:

```
| ファイル | 種類 | 関心事 |
|---------|------|--------|
| src/auth.ts | ソースコード | 認証機能追加 |
| docs/README.md | ドキュメント | ドキュメント更新 |
```

### ステップ3/5: コミット計画の確認

`AskUserQuestion` で分割計画をユーザーに提示する。

**単一の関心事の場合:**

変更が1つの関心事にまとまっている場合は、分割提案をスキップしてステップ4に進む。

**複数の関心事がある場合:**

`AskUserQuestion` の `question` テキスト内に分割計画を記載し、選択肢は承認/修正の2択にする。

question の例:

```
以下のように分割してコミットします:
1. feat: ユーザー認証を追加 (auth.ts, login.tsx)
2. docs: READMEを更新 (README.md)
3. chore: 依存関係を更新 (package.json)
```

選択肢:

- この計画でコミットする
- 修正したい（Other で指示を入力）

### ステップ4/5: コミットメッセージの選択と実行

各グループごとに以下を繰り返す:

1. `AskUserQuestion` でコミットメッセージ候補を3つ提示

- **header**: `コミット`
- **question**: `コミットメッセージを選択してください`
- **options**: 候補3つ
  - **label**: コミットメッセージ本体（`<type>[scope]: <概要>`）
  - **description**: そのメッセージを選ぶ理由・観点の補足（Why）
- 概要の書き方: What（何を変更したか）よりも **Why（なぜ変更したか）** を意識して簡潔に記載
  - 良い例: `〇〇取得時のN+1問題を解決`、`ルーティングを実現するためにライブラリ「〇〇」を依存関係に追加`
  - 悪い例: `〇〇ファイルを修正`、`〇〇を変更`
- 候補の多様性:
  - 候補1: 最も具体的で詳細な説明
  - 候補2: やや抽象的・簡潔な説明
  - 候補3: 異なる観点（別の type/scope の可能性）

2. ユーザーが選択（または Other で自由入力）
3. コミットメッセージを組み立てる（footer を自動付与）

- `Co-Authored-By` は常に付与
- footer はユーザーの選択肢には含めず、コミット実行時に自動追加する

4. 該当ファイルをステージしてコミットを実行する

- `git add <ファイルパス>` で個別にステージ（**`git add .` や `git add -A` は絶対に使わない**）
- 機密ファイル（.env, credentials 等）が含まれていないか確認
- ステージングとコミットを連続して実行する（中断時にステージ解除が不要になる）

コミットの実行（HEREDOC を使用）:

```bash
git commit -m "$(cat <<'EOF'
feat(auth): セッション有効期限切れ時の自動更新を実装

リフレッシュトークンによる透過的なトークン更新を追加。

Co-Authored-By: <AIエージェント名> <メールアドレス>
EOF
)"
```

### ステップ5/5: 完了サマリー

すべてのコミット完了後、以下を表示:

```bash
git log --oneline -n <コミット数>
```

```
コミット完了:
- <hash> <type>: <概要>
- <hash> <type>: <概要>
```
